// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pub status "?bad code"

pri status "?internal error: inconsistent I/O"

pub struct decoder?(
	literal_width base.u32[..8],
	flush_j base.u32[..8191],
	suffixes array[4096] base.u8,
	prefixes array[4096] base.u16[..4095],
	prefix_lengths array[4096] base.u16[..4095],
	output array[8192] base.u8,
)

pub func decoder.set_literal_width!(lw base.u32[2..8]) {
	this.literal_width = args.lw
}

pub func decoder.decode!??(dst base.io_writer, src base.io_reader) {
	// These variables don't change over the lifetime of this func.
	var literal_width base.u32[2..8] = 8
	if this.literal_width >= 2 {
		literal_width = this.literal_width
	}
	var clear_code base.u32[4..256] = (1 as base.u32) << literal_width
	var end_code base.u32[5..257] = clear_code + 1

	// These variables do change.
	//
	// save_code is the code for which, after decoding a code, we save what the
	// next back-reference expands to. The README.md file also calls this value
	// `max`. 4096 means do not save.
	var save_code base.u32[..4096] = end_code
	var prev_code base.u32[..4095]
	var width base.u32[..12] = literal_width + 1

	// First, use the j variable to iterate over prefix_lengths.
	var j base.u32[..8191]
	while j < clear_code {
		assert j < 256 via "a < b: a < c; c <= b"(c:clear_code)
		this.prefix_lengths[j] = 0
		j += 1
	}
	// For the rest of this function, j is such that output[:j] accumulates the
	// decoded output to write (in batches) to args.dst.
	j = 0

	// These variables produce src's bits in Least Significant Bits order.
	var bits base.u32
	var n_bits base.u32[..31]

	while true {
		if args.src.available() >= 4 {
			// Read 4 bytes, using the "Variant 4" technique of
			// https://fgiesen.wordpress.com/2018/02/20/reading-bits-in-far-too-many-ways-part-2/
			bits |= (args.src.peek_u32le() as base.u32) ~mod<< n_bits
			args.src.skip_fast!(actual:(31 - n_bits) >> 3, worst_case:3)
			n_bits |= 24
			assert width <= n_bits via "a <= b: a <= c; c <= b"(c:12)
			assert n_bits >= width via "a >= b: b <= a"()
		} else {
			while n_bits < width,
				post n_bits >= width,
			{
				assert n_bits < 12 via "a < b: a < c; c <= b"(c:width)
				bits |= (args.src.read_u8!??() as base.u32) << n_bits
				n_bits += 8
			}
		}

		var code base.u32[..4095] = bits.low_bits(n:width)
		bits >>= width
		n_bits -= width

		if code < clear_code {
			assert code < 256 via "a < b: a < c; c <= b"(c:clear_code)
			this.output[j] = code as base.u8
			j = (j + 1) & 8191
			if save_code <= 4095 {
				this.suffixes[save_code] = code as base.u8
				this.prefixes[save_code] = prev_code as base.u16
				this.prefix_lengths[save_code] = (this.prefix_lengths[prev_code] + 1) & 4095
				save_code += 1
				if (save_code == ((1 as base.u32) << width)) and (width < 12) {
					width += 1
				}
				prev_code = code
			}

		} else if code <= end_code {
			if code == end_code {
				break
			}
			save_code = end_code
			prev_code = 0
			width = literal_width + 1
		} else if code <= save_code {
			var c base.u32[..4095] = code
			if code == save_code {
				c = prev_code
			}

			// Letting old_j and new_j denote the values of j before and after
			// these two lines of code, the decoded bytes will be written to
			// output[old_j:new_j]. They will be written back-to-front,
			// starting by writing output[o], also known as output[new_j - 1].
			//
			// In the special case that code == save_code, the decoded bytes
			// contain an extra copy (at the end) of the first byte, and will
			// be written to output[old_j:new_j + 1].
			var o base.u32[..8191] = (j + (this.prefix_lengths[c] as base.u32)) & 8191
			j = (o + 1) & 8191

			while c >= clear_code,
				post c < 256 via "a < b: a < c; c <= b"(c:clear_code),
			{
				this.output[o] = this.suffixes[c]
				// This line is essentially "o -= 1". The "& 8191" is a no-op
				// in practice, but is necessary for the overflow checker.
				o = (o ~mod- 1) & 8191
				c = this.prefixes[c] as base.u32
			}
			this.output[o] = c as base.u8

			if code == save_code {
				this.output[j] = c as base.u8
				j = (j + 1) & 8191
			}

			if save_code <= 4095 {
				this.suffixes[save_code] = c as base.u8
				this.prefixes[save_code] = prev_code as base.u16
				this.prefix_lengths[save_code] = (this.prefix_lengths[prev_code] + 1) & 4095
				save_code += 1
				if (save_code == ((1 as base.u32) << width)) and (width < 12) {
					width += 1
				}
				prev_code = code
			}

		} else {
			return status "?bad code"
		}

		// Flush the output if it could be too full to contain the entire
		// decoding of the next code. The longest possible decoding is slightly
		// less than 4096 and output's length is 8192, so a conservative
		// threshold is ensuring that j <= 4095.
		if j > 4095 {
			// Rewind args.src, if we've read too many bits.
			while n_bits >= 8 {
				n_bits -= 8
				if args.src.can_undo_byte() {
					args.src.undo_byte!()
				} else {
					return status "?internal error: inconsistent I/O"
				}
			}
			bits = bits.low_bits(n:n_bits)

			this.flush_j = j
			this.flush!??(dst:args.dst)
			j = 0
		}
	}

	if j > 0 {
		// Rewind args.src, if we've read too many bits.
		while n_bits >= 8 {
			n_bits -= 8
			if args.src.can_undo_byte() {
				args.src.undo_byte!()
			} else {
				return status "?internal error: inconsistent I/O"
			}
		}
		bits = bits.low_bits(n:n_bits)

		this.flush_j = j
		this.flush!??(dst:args.dst)
	}
}

pri func decoder.flush!??(dst base.io_writer) {
	var i base.u32[..8191]
	var j base.u32[..8191] = this.flush_j
	while true {
		if i > j {
			return status "?internal error: inconsistent I/O"
		}
		var s slice base.u8 = this.output[i:j]
		var n base.u64 = args.dst.copy_from_slice!(s:s)
		if n == s.length() {
			return
		}
		i = (i + ((n & 8191) as base.u32)) & 8191
		yield status "$short write"
	}
}

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

pub status "?bad code"

pri status "?internal error: inconsistent I/O"

pub struct decoder?(
	literal_width base.u32[..8],
	flush_j base.u32[..8191],
	suffixes array[4096] array[8] base.u8,
	prefixes array[4096] base.u16[..4095],
	// lm1s is the "length minus 1"s of the values for the implicit key-value
	// table in this decoder. See std/lzw/README.md for more detail.
	lm1s array[4096] base.u16[..4095],
	output array[8192 + 7] base.u8,
)

pub func decoder.set_literal_width!(lw base.u32[2..8]) {
	this.literal_width = args.lw
}

pub func decoder.decode!??(dst base.io_writer, src base.io_reader) {
	// These variables don't change over the lifetime of this func.
	var literal_width base.u32[2..8] = 8
	if this.literal_width >= 2 {
		literal_width = this.literal_width
	}
	var clear_code base.u32[4..256] = (1 as base.u32) << literal_width
	var end_code base.u32[5..257] = clear_code + 1

	// These variables do change.
	//
	// save_code is the code for which, after decoding a code, we save what the
	// next back-reference expands to. The README.md file also calls this value
	// `max`. 4096 means do not save.
	var save_code base.u32[..4096] = end_code
	var prev_code base.u32[..4095] = end_code
	var width base.u32[..12] = literal_width + 1

	// First, use the j variable to initialize some state.
	var j base.u32[..8191]
	while j < clear_code {
		assert j < 256 via "a < b: a < c; c <= b"(c:clear_code)
		this.lm1s[j] = 0
		this.suffixes[j][0] = j as base.u8
		j += 1
	}
	// For the rest of this function, j is such that output[:j] accumulates the
	// decoded output to write (in batches) to args.dst.
	j = 0

	// These variables produce src's bits in Least Significant Bits order.
	var bits base.u32
	var n_bits base.u32[..31]

	while true {
		if n_bits < width {
			if args.src.available() >= 4 {
				// Read 4 bytes, using the "Variant 4" technique of
				// https://fgiesen.wordpress.com/2018/02/20/reading-bits-in-far-too-many-ways-part-2/
				bits |= (args.src.peek_u32le() as base.u32) ~mod<< n_bits
				args.src.skip_fast!(actual:(31 - n_bits) >> 3, worst_case:3)
				n_bits |= 24
				assert width <= n_bits via "a <= b: a <= c; c <= b"(c:12)
				assert n_bits >= width via "a >= b: b <= a"()
			} else {
				assert n_bits < 12 via "a < b: a < c; c <= b"(c:width)
				while true,
					pre n_bits < 12,
					post n_bits >= width,
				{
					while args.src.available() <= 0,
						inv n_bits < 12,
						post args.src.available() >= 1,
					{
						if j > 0 {
							this.flush_j = j
							this.flush!??(dst:args.dst)
							j = 0
						}
						yield base."$short read"
					}
					bits |= (args.src.peek_u8() as base.u32) << n_bits
					args.src.skip_fast!(actual:1, worst_case:1)
					n_bits += 8
					if n_bits >= width {
						break
					}
					assert n_bits < 12 via "a < b: a < c; c <= b"(c:width)
				}
			}
		}

		var code base.u32[..4095] = bits.low_bits(n:width)
		bits >>= width
		n_bits -= width

		if code < clear_code {
			assert code < 256 via "a < b: a < c; c <= b"(c:clear_code)
			this.output[j] = code as base.u8
			j = (j + 1) & 8191
			if save_code <= 4095 {
				var lm1_a base.u16[..4095] = (this.lm1s[prev_code] + 1) & 4095
				this.lm1s[save_code] = lm1_a

				if (lm1_a % 8) != 0 {
					this.prefixes[save_code] = this.prefixes[prev_code]
					this.suffixes[save_code] = this.suffixes[prev_code]
					this.suffixes[save_code][lm1_a % 8] = code as base.u8
				} else {
					this.prefixes[save_code] = prev_code as base.u16
					this.suffixes[save_code][0] = code as base.u8
				}

				save_code += 1
				if (save_code == ((1 as base.u32) << width)) and (width < 12) {
					width += 1
				}
				prev_code = code
			}

		} else if code <= end_code {
			if code == end_code {
				break
			}
			save_code = end_code
			prev_code = end_code
			width = literal_width + 1

		} else if code <= save_code {
			var c base.u32[..4095] = code
			if code == save_code {
				c = prev_code
			}

			// Letting old_j and new_j denote the values of j before and after
			// these two lines of code, the decoded bytes will be written to
			// output[old_j:new_j]. They will be written back-to-front, 8 bytes
			// at a time, starting by writing output[o:o + 8], which will
			// contain output[new_j - 1].
			//
			// In the special case that code == save_code, the decoded bytes
			// contain an extra copy (at the end) of the first byte, and will
			// be written to output[old_j:new_j + 1].
			var o base.u32[..8191] = (j + ((this.lm1s[c] as base.u32) & 0xFFFFFFF8)) & 8191
			j = (j + 1 + (this.lm1s[c] as base.u32)) & 8191

			var steps base.u32 = (this.lm1s[c] as base.u32) >> 3
			while true {
				assert o <= (o + 8) via "a <= (a + b): 0 <= b"(b:8)

				// The final "8" is redundant semantically, but helps the
				// wuffs-c code generator recognize that both slices have the
				// same constant length, and hence produce efficient C code.
				this.output[o:o + 8].copy_from_slice!(s:this.suffixes[c][:8])

				if steps <= 0 {
					break
				}
				steps -= 1

				// This line is essentially "o -= 8". The "& 8191" is a no-op
				// in practice, but is necessary for the overflow checker.
				o = (o ~mod- 8) & 8191
				c = this.prefixes[c] as base.u32
			}
			var first_byte base.u8 = this.suffixes[c][0]

			if code == save_code {
				this.output[j] = first_byte
				j = (j + 1) & 8191
			}

			if save_code <= 4095 {
				var lm1_b base.u16[..4095] = (this.lm1s[prev_code] + 1) & 4095
				this.lm1s[save_code] = lm1_b

				if (lm1_b % 8) != 0 {
					this.prefixes[save_code] = this.prefixes[prev_code]
					this.suffixes[save_code] = this.suffixes[prev_code]
					this.suffixes[save_code][lm1_b % 8] = first_byte
				} else {
					this.prefixes[save_code] = prev_code as base.u16
					this.suffixes[save_code][0] = first_byte as base.u8
				}

				save_code += 1
				if (save_code == ((1 as base.u32) << width)) and (width < 12) {
					width += 1
				}
				prev_code = code
			}

		} else {
			return "?bad code"
		}

		// Flush the output if it could be too full to contain the entire
		// decoding of the next code. The longest possible decoding is slightly
		// less than 4096 and output's length is 8192, so a conservative
		// threshold is ensuring that j <= 4095.
		if j > 4095 {
			// Rewind args.src, if we've read too many bits.
			while n_bits >= 8 {
				n_bits -= 8
				if args.src.can_undo_byte() {
					args.src.undo_byte!()
				} else {
					return "?internal error: inconsistent I/O"
				}
			}
			bits = bits.low_bits(n:n_bits)

			this.flush_j = j
			this.flush!??(dst:args.dst)
			j = 0
		}
	}

	if j > 0 {
		// Rewind args.src, if we've read too many bits.
		while n_bits >= 8 {
			n_bits -= 8
			if args.src.can_undo_byte() {
				args.src.undo_byte!()
			} else {
				return "?internal error: inconsistent I/O"
			}
		}
		bits = bits.low_bits(n:n_bits)

		this.flush_j = j
		this.flush!??(dst:args.dst)
	}
}

pri func decoder.flush!??(dst base.io_writer) {
	var i base.u32[..8191]
	var j base.u32[..8191] = this.flush_j
	while true {
		if i > j {
			return "?internal error: inconsistent I/O"
		}
		var s slice base.u8 = this.output[i:j]
		var n base.u64 = args.dst.copy_from_slice!(s:s)
		if n == s.length() {
			return ok
		}
		i = (i + ((n & 8191) as base.u32)) & 8191
		yield base."$short write"
	}
}
